public class Lagrange {
    private Polynome poly; // Результирующий полином
    private double[] xArray;  // Массив аргументов
    private double[] yArray;  // Массив значений

    // Конструктор, на вход сетка значений
    public Lagrange(Grid grid) {
        xArray = grid.getArgs();
        yArray = grid.getVals();
        poly = new Polynome(); // Объект собираемого полинома
        interpolate(); // Метод интерполяции
    }

    // Метод с помощью значений полученных из сетки вычисляет полином
    private void interpolate() {
        Polynome t = new Polynome(1, 1);  // Вспомогательный полином степени 1, у него будем менять свободный член
        Polynome f_i = new Polynome(); // i-я элементарная функция

        double c = 1; // Константа для вычисления элементарной функции

        // ------------------------------  Вычисление первой элементарной функции  ------------------------------------------
        c /= (xArray[0] - xArray[1]); // Первый множитель в знаменателе константы
        t.change((-1) * xArray[1]); // Меняем свободный член для первого множителя эл функции
        f_i.sum(t); // Устанавливаем f_i = t, т.к. в f_i пустой то sum() просто скопирует

        for(int j = 2; j < xArray.length; j++) { // Продолжаем вычислять константу и элементарную функцию j = 2..n
            c /= (xArray[0] - xArray[j]); // Делим константу на следующий множитель
            t.change((-1) * xArray[j]); // Меняем свободный член, получая следующий множитель эл функции
            f_i.multiply(t); // Умножаем на следующий множитель
        }

        f_i.multiply(c * yArray[0]); // Умножение множителей на константу и на y_i
        poly.sum(f_i); // Прибавление элементарной функции умноженной на y_i в интерполянту

        // --------------------------  Вычисление всех оставшихся элементарных функций  -----------------------------
        for(int i = 1; i < yArray.length; i++) {
            f_i = new Polynome(); // Очередная элементарная функция

            c = 1 / (xArray[i] - xArray[0]); // Первый множитель в знаменателе константы
            t.change((-1) * xArray[0]); // Меняем свободный член для первого множителя эл функции
            f_i.sum(t); // Устанавливаем f_i = t, т.к. в f_i пустой то sum() просто скопирует

            // Продолжаем вычислять константу и элементарную функцию !ДО i ЭЛЕМЕНТА!
            for(int j = 1; j < i; j++) {
                c /= (xArray[i] - xArray[j]); // Делим константу на следующий множитель
                t.change((-1) * xArray[j]); // Меняем свободный член, получая следующий множитель эл функции
                f_i.multiply(t); // Умножаем на следующий множитель
            }

            // После i элемента
            for(int j = i+1; j < xArray.length; j++) { // Продолжаем вычислять константу и элементарную функцию j = 2..n
                c /= (xArray[i] - xArray[j]); // Делим константу на следующий множитель
                t.change((-1) * xArray[j]); // Меняем свободный член, получая следующий множитель эл функции
                f_i.multiply(t); // Умножаем на следующий множитель
            }

            f_i.multiply(c * yArray[i]); // Умножение множителей на константу и на y_i
            poly.sum(f_i); // Прибавление элементарной функции умноженной на y_i в интерполянту
        }
    }

    public Polynome getPoly(){
        return poly;
    }
}

